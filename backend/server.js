/**
 * NFCchain Backend API
 * Node.js + Express + Firebase Firestore
 * 
 * Features:
 * - Premium support
 * - Email verification during activation
 * - Custom passcode creation
 * - Password reset via email
 */

const express = require('express');
const cors = require('cors');
const bcrypt = require('bcrypt');
const crypto = require('crypto');
const nodemailer = require('nodemailer');
const path = require('path');
require('dotenv').config();

// Firebase Admin SDK
const admin = require('firebase-admin');
// Support both file and environment variable for service account (for deployment)
const serviceAccount = process.env.FIREBASE_SERVICE_ACCOUNT 
    ? JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT)
    : require('./firebase-service-account.json');

// Initialize Firebase Admin
admin.initializeApp({
    credential: admin.credential.cert(serviceAccount),
    databaseURL: process.env.FIREBASE_DATABASE_URL,
    storageBucket: process.env.FIREBASE_STORAGE_BUCKET || 'nfcchain.firebasestorage.app'
});

const db = admin.firestore();
const bucket = admin.storage().bucket();

// Cloudflare R2 Configuration
const { S3Client, PutObjectCommand, DeleteObjectCommand } = require('@aws-sdk/client-s3');
const { Upload } = require('@aws-sdk/lib-storage');

const r2Client = new S3Client({
    region: 'auto',
    endpoint: process.env.R2_ENDPOINT,
    credentials: {
        accessKeyId: process.env.R2_ACCESS_KEY_ID,
        secretAccessKey: process.env.R2_SECRET_ACCESS_KEY,
    },
});

console.log('üåê Cloudflare R2 initialized:', process.env.R2_BUCKET_NAME);
console.log('üì¶ Public URL:', process.env.R2_PUBLIC_URL);

const app = express();

// Middleware
// CORS configuration - update with your production domains
const allowedOrigins = [
    'http://localhost:3000',
    'http://localhost:8080',
    'http://127.0.0.1:3000',
    process.env.FRONTEND_URL, // Add your frontend URL as environment variable
].filter(Boolean); // Remove undefined values

app.use(cors({
    origin: process.env.NODE_ENV === 'production' 
        ? allowedOrigins 
        : true, // Allow all in development
    credentials: true
}));
// Increase payload size limit to 50MB for base64 images
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ limit: '50mb', extended: true }));

// Serve static files from the public directory
app.use(express.static(path.join(__dirname, '../public')));
// Also serve src folder for shared CSS/JS files
app.use('/src', express.static(path.join(__dirname, '../src')));

// Email configuration
const transporter = nodemailer.createTransport({
    service: 'gmail',
    auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASSWORD
    }
});

// ==========================================
// DATA MODEL
// ==========================================

/**
 * NFCchain Document Structure
 * 
 * {
 *   memoryId: String,           // Public ID (e.g., "8F3KQ2")
 *   passcodeHash: String,        // Hashed user-created passcode
 *   email: String,               // User's email (required for activation)
 *   emailVerified: Boolean,      // Email verification status
 *   status: String,              // "unused" | "written" | "shipped" | "activated"
 *   premium: Boolean,            // Premium account flag
 *   photoLimit: Number,          // 5 (standard) or 100 (premium)
 *   photoCount: Number,          // Current number of photos
 *   createdAt: Date,             // When generated by admin
 *   assignedAt: Date,            // When assigned to order
 *   activatedAt: Date,           // When user completed activation
 *   orderId: String,             // Order ID reference
 *   customerName: String,        // Customer name (optional)
 *   
 *   // Gallery Data
 *   galleryTitle: String,
 *   galleryData: Object,         // Theme, colors, etc.
 *   images: Array,               // Image metadata
 *   letterContent: Object,       // Welcome letter
 *   spotifyUrl: String,          // Spotify embed URL
 *   
 *   // Password Reset
 *   resetToken: String,          // Temporary reset token
 *   resetTokenExpiry: Date       // Token expiration time
 * }
 */

// ==========================================
// UTILITY FUNCTIONS
// ==========================================

function generateMemoryId(prefix = '') {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let id = prefix;
    const length = prefix ? 4 : 6;
    
    for (let i = 0; i < length; i++) {
        id += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return id;
}

function generateVerificationCode() {
    return Math.floor(100000 + Math.random() * 900000).toString();
}

function generateResetToken() {
    return crypto.randomBytes(32).toString('hex');
}

async function hashPasscode(passcode) {
    return await bcrypt.hash(passcode, 10);
}

async function verifyPasscode(passcode, hash) {
    return await bcrypt.compare(passcode, hash);
}

// Temporary storage for verification codes (use Redis in production)
const verificationCodes = new Map();

// Helper function to convert Firestore timestamps to ISO strings
function formatTimestamp(timestamp) {
    if (!timestamp) return null;
    if (timestamp._seconds) {
        return new Date(timestamp._seconds * 1000).toISOString();
    }
    if (timestamp.toDate) {
        return timestamp.toDate().toISOString();
    }
    return timestamp;
}

// ==========================================
// ADMIN API - BATCH GENERATION
// ==========================================

app.post('/api/admin/generate-batch', async (req, res) => {
    const { quantity, photoLimit, prefix, premium } = req.body;

    try {
        const batch = [];
        const usedIds = new Set();

        // Get existing IDs to avoid duplicates
        const existingSnapshot = await db.collection('nfcChains')
            .select('memoryId')
            .get();
        
        existingSnapshot.forEach(doc => {
            usedIds.add(doc.data().memoryId);
        });

        // Generate batch
        for (let i = 0; i < quantity; i++) {
            let memoryId;
            do {
                memoryId = generateMemoryId(prefix);
            } while (usedIds.has(memoryId));

            usedIds.add(memoryId);

            const nfcChain = {
                memoryId,
                passcodeHash: null,
                email: null,
                emailVerified: false,
                status: 'unused',
                premium: premium || false,
                photoLimit: parseInt(photoLimit) || 5,
                photoCount: 0,
                createdAt: admin.firestore.FieldValue.serverTimestamp(),
                assignedAt: null,
                activatedAt: null,
                orderId: null,
                customerName: null,
                viewUrl: `https://smartlocket.com/m/${memoryId}`,
                
                // Gallery defaults
                galleryTitle: 'SmartLocket Gallery',
                galleryData: {},
                images: [],
                letterContent: {
                    title: 'Welcome to SmartLocket',
                    paragraphs: [
                        'As you scroll through this magical journey...',
                        'This gallery is a celebration of precious moments...',
                        'Continue scrolling to reveal the gallery...'
                    ]
                },
                spotifyUrl: null,
                
                // Reset fields
                resetToken: null,
                resetTokenExpiry: null
            };

            batch.push(nfcChain);
        }

        // Batch write to Firestore (max 500 per batch)
        const batchSize = 500;
        for (let i = 0; i < batch.length; i += batchSize) {
            const writeBatch = db.batch();
            const chunk = batch.slice(i, i + batchSize);
            
            chunk.forEach(item => {
                const docRef = db.collection('nfcChains').doc(item.memoryId);
                writeBatch.set(docRef, item);
            });
            
            await writeBatch.commit();
        }

        res.json({
            success: true,
            count: batch.length,
            batch: batch.map(item => ({
                memoryId: item.memoryId,
                viewUrl: item.viewUrl,
                premium: item.premium,
                photoLimit: item.photoLimit
            }))
        });

    } catch (error) {
        console.error('Batch generation error:', error);
        res.status(500).json({ success: false, message: 'Failed to generate batch' });
    }
});

// ==========================================
// ADMIN API - DASHBOARD STATS
// ==========================================

app.get('/api/admin/stats', async (req, res) => {
    try {
        const snapshot = await db.collection('nfcChains').get();
        
        const stats = {
            total: 0,
            unused: 0,
            written: 0,
            activated: 0,
            premium: 0
        };

        snapshot.forEach(doc => {
            const data = doc.data();
            stats.total++;
            
            if (data.status === 'unused') stats.unused++;
            if (data.status === 'written') stats.written++;
            if (data.status === 'activated') stats.activated++;
            if (data.premium) stats.premium++;
        });

        res.json(stats);

    } catch (error) {
        console.error('Stats error:', error);
        res.status(500).json({ message: 'Failed to fetch stats' });
    }
});

// ==========================================
// ADMIN API - INVENTORY
// ==========================================

app.get('/api/admin/inventory', async (req, res) => {
    try {
        const { page = 1, limit = 50, status, premium, search } = req.query;
        
        let query = db.collection('nfcChains');
        
        // Apply filters
        if (status && status !== 'all') {
            query = query.where('status', '==', status);
        }
        
        if (premium && premium !== 'all') {
            query = query.where('premium', '==', premium === 'true');
        }
        
        // Get all results
        const snapshot = await query.orderBy('createdAt', 'desc').get();
        
        let results = [];
        snapshot.forEach(doc => {
            const data = doc.data();
            
            // Apply search filter if provided
            if (search && !data.memoryId.toLowerCase().includes(search.toLowerCase())) {
                return;
            }
            
            results.push({
                memoryId: data.memoryId,
                status: data.status,
                premium: data.premium,
                photoLimit: data.photoLimit,
                photoCount: data.photoCount,
                orderId: data.orderId,
                email: data.email,
                createdAt: formatTimestamp(data.createdAt),
                activatedAt: formatTimestamp(data.activatedAt),
                viewUrl: data.viewUrl
            });
        });
        
        // Manual pagination
        const startIndex = (page - 1) * limit;
        const endIndex = startIndex + parseInt(limit);
        const paginatedResults = results.slice(startIndex, endIndex);
        
        res.json({
            success: true,
            data: paginatedResults,
            pagination: {
                page: parseInt(page),
                limit: parseInt(limit),
                total: results.length,
                pages: Math.ceil(results.length / limit)
            }
        });

    } catch (error) {
        console.error('Inventory error:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch inventory' });
    }
});

// ==========================================
// ADMIN API - NEXT UNUSED
// ==========================================

app.get('/api/admin/next-unused', async (req, res) => {
    try {
        const snapshot = await db.collection('nfcChains')
            .where('status', '==', 'unused')
            .orderBy('createdAt', 'asc')
            .limit(1)
            .get();
        
        if (snapshot.empty) {
            return res.status(404).json({ 
                success: false, 
                message: 'No unused SmartLockets available' 
            });
        }
        
        const doc = snapshot.docs[0];
        const data = doc.data();
        
        res.json({
            success: true,
            data: {
                memoryId: data.memoryId,
                viewUrl: data.viewUrl,
                premium: data.premium,
                photoLimit: data.photoLimit,
                createdAt: formatTimestamp(data.createdAt)
            }
        });

    } catch (error) {
        console.error('Next unused error:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch next unused' });
    }
});

// ==========================================
// ADMIN API - MARK AS WRITTEN
// ==========================================

app.post('/api/admin/mark-written/:memoryId', async (req, res) => {
    const { memoryId } = req.params;
    
    try {
        const docRef = db.collection('nfcChains').doc(memoryId);
        const doc = await docRef.get();
        
        if (!doc.exists) {
            return res.status(404).json({ 
                success: false, 
                message: 'SmartLocket not found' 
            });
        }
        
        await docRef.update({
            status: 'written',
            writtenAt: admin.firestore.FieldValue.serverTimestamp()
        });
        
        res.json({
            success: true,
            message: 'SmartLocket marked as written',
            memoryId
        });

    } catch (error) {
        console.error('Mark written error:', error);
        res.status(500).json({ success: false, message: 'Failed to mark as written' });
    }
});

// ==========================================
// ADMIN API - ASSIGN TO ORDER
// ==========================================

app.post('/api/admin/assign-order', async (req, res) => {
    const { memoryId, orderId, customerName, customerEmail } = req.body;
    
    try {
        const docRef = db.collection('nfcChains').doc(memoryId);
        const doc = await docRef.get();
        
        if (!doc.exists) {
            return res.status(404).json({ 
                success: false, 
                message: 'SmartLocket not found' 
            });
        }
        
        await docRef.update({
            orderId,
            customerName: customerName || null,
            email: customerEmail || null,
            assignedAt: admin.firestore.FieldValue.serverTimestamp(),
            status: 'shipped'
        });
        
        res.json({
            success: true,
            message: 'Order assigned successfully',
            memoryId,
            orderId
        });

    } catch (error) {
        console.error('Assign order error:', error);
        res.status(500).json({ success: false, message: 'Failed to assign order' });
    }
});

// ==========================================
// ACTIVATION API - EMAIL VERIFICATION
// ==========================================

app.post('/api/activation/send-code', async (req, res) => {
    const { memoryId, email } = req.body;

    try {
        // Check if memory exists and is not already activated
        const docRef = db.collection('nfcChains').doc(memoryId);
        const doc = await docRef.get();
        
        if (!doc.exists) {
            return res.status(404).json({ message: 'NFCchain not found' });
        }
        
        const nfcData = doc.data();
        
        if (nfcData.status === 'activated') {
            return res.status(400).json({ message: 'SmartLocket already activated' });
        }

        // Generate verification code
        const code = generateVerificationCode();
        
        // Store code with expiry (5 minutes)
        verificationCodes.set(`${memoryId}:${email}`, {
            code,
            expiry: Date.now() + 5 * 60 * 1000
        });

        // Send email
        await transporter.sendMail({
            from: 'SmartLocket <memorychain@yourdomain.com>',
            to: email,
            subject: 'Verify Your SmartLocket - Verification Code',
            html: `
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <div style="background: linear-gradient(135deg, #000000ff 0%, #ffffffff 100%); padding: 30px; text-align: center; color: white;">
                        <h1>SmartLocket</h1>
                        <p>Activate Your Memory Locket</p>
                    </div>
                    <div style="padding: 30px; background: #f9fafb;">
                        <h2>Verification Code</h2>
                        <p>Your SmartLocket ID: <strong>${memoryId}</strong></p>
                        <p>Enter this code to verify your email:</p>
                        <div style="background: white; padding: 20px; text-align: center; margin: 20px 0; border-radius: 10px;">
                            <h1 style="color: #000000ff; font-size: 36px; letter-spacing: 8px; margin: 0;">${code}</h1>
                        </div>
                        <p style="color: #666; font-size: 14px;">This code will expire in 5 minutes.</p>
                        <p style="color: #666; font-size: 14px;">If you didn't request this, please ignore this email.</p>
                    </div>
                    <div style="padding: 20px; text-align: center; color: #666; font-size: 12px;">
                        <p>&copy; 2025 SmartLocket. All rights reserved.</p>
                    </div>
                </div>
            `
        });

        res.json({ success: true, message: 'Verification code sent' });

    } catch (error) {
        console.error('Send code error:', error);
        res.status(500).json({ message: 'Failed to send verification code' });
    }
});

app.post('/api/activation/verify-code', async (req, res) => {
    const { memoryId, email, code } = req.body;

    try {
        const key = `${memoryId}:${email}`;
        const stored = verificationCodes.get(key);

        if (!stored) {
            return res.status(400).json({ message: 'No verification code found' });
        }

        if (Date.now() > stored.expiry) {
            verificationCodes.delete(key);
            return res.status(400).json({ message: 'Verification code expired' });
        }

        if (stored.code !== code) {
            return res.status(400).json({ message: 'Invalid verification code' });
        }

        // Code is valid, remove it
        verificationCodes.delete(key);

        // Generate temporary token for next step
        const token = crypto.randomBytes(32).toString('hex');
        
        // Store token temporarily (use Redis in production)
        verificationCodes.set(`token:${token}`, {
            memoryId,
            email,
            expiry: Date.now() + 15 * 60 * 1000 // 15 minutes
        });

        res.json({ 
            success: true, 
            token,
            message: 'Email verified successfully' 
        });

    } catch (error) {
        console.error('Verify code error:', error);
        res.status(500).json({ message: 'Failed to verify code' });
    }
});

app.post('/api/activation/resend-code', async (req, res) => {
    // Same as send-code but with rate limiting
    return app.post('/api/activation/send-code')(req, res);
});

// ==========================================
// ACTIVATION API - COMPLETE WITH PASSCODE
// ==========================================

app.post('/api/activation/complete', async (req, res) => {
    const { memoryId, email, passcode } = req.body;
    const token = req.headers.authorization?.replace('Bearer ', '');

    try {
        // Verify token
        const tokenData = verificationCodes.get(`token:${token}`);
        
        if (!tokenData) {
            return res.status(401).json({ message: 'Invalid or expired token' });
        }

        if (Date.now() > tokenData.expiry) {
            verificationCodes.delete(`token:${token}`);
            return res.status(401).json({ message: 'Token expired' });
        }

        if (tokenData.memoryId !== memoryId || tokenData.email !== email) {
            return res.status(401).json({ message: 'Token mismatch' });
        }

        // Hash the user's passcode
        const passcodeHash = await hashPasscode(passcode);

        // Update database - Activate the NFCchain
        const docRef = db.collection('nfcChains').doc(memoryId);
        await docRef.update({
            email,
            emailVerified: true,
            passcodeHash,
            status: 'activated',
            activatedAt: admin.firestore.FieldValue.serverTimestamp()
        });

        // Get the photo limit for welcome email
        const doc = await docRef.get();
        const nfcData = doc.data();
        const photoLimit = nfcData.photoLimit || 5;

        // Generate session token
        const sessionToken = crypto.randomBytes(32).toString('hex');
        
        // Store session (use Redis with expiry in production)
        verificationCodes.set(`session:${sessionToken}`, {
            memoryId,
            email,
            expiry: Date.now() + 7 * 24 * 60 * 60 * 1000 // 7 days
        });

        // Clean up verification token
        verificationCodes.delete(`token:${token}`);

        // Send welcome email
        await transporter.sendMail({
            from: 'SmartLocket <memorychain@yourdomain.com>',
            to: email,
            subject: 'Welcome to SmartLocket!',
            html: `
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; text-align: center; color: white;">
                        <h1>üéâ Welcome to SmartLocket!</h1>
                    </div>
                    <div style="padding: 30px;">
                        <h2>Your SmartLocket is Ready!</h2>
                        <p>Your personal memory gallery has been successfully activated.</p>
                        
                        <div style="background: #f3f4f6; padding: 20px; border-radius: 10px; margin: 20px 0;">
                            <p style="margin: 0;"><strong>SmartLocket ID:</strong> ${memoryId}</p>
                            <p style="margin: 10px 0 0 0;"><strong>Access URL:</strong> <a href="https://smartlocket.com/m/${memoryId}">smartlocket.com/m/${memoryId}</a></p>
                        </div>
                        
                        <h3>What's Next?</h3>
                        <ul>
                            <li>Upload up to ${photoLimit} photos</li>
                            <li>Customize your gallery theme</li>
                            <li>Add a personal welcome letter</li>
                            <li>Connect your favorite Spotify track</li>
                        </ul>
                        
                        <p><strong>Important:</strong> Save your passcode securely. You'll need it to edit your gallery.</p>
                        
                        <div style="text-align: center; margin: 30px 0;">
                            <a href="https://smartlocket.com/m/${memoryId}" style="background: #667eea; color: white; padding: 15px 30px; text-decoration: none; border-radius: 10px; display: inline-block;">Open My Gallery</a>
                        </div>
                    </div>
                </div>
            `
        });

        res.json({
            success: true,
            sessionToken,
            memoryId,
            message: 'Activation complete!'
        });

    } catch (error) {
        console.error('Activation complete error:', error);
        res.status(500).json({ message: 'Failed to complete activation' });
    }
});

// ==========================================
// PASSWORD RESET API
// ==========================================

app.post('/api/password-reset/request', async (req, res) => {
    const { memoryId, email } = req.body;

    try {
        // Verify memory exists and email matches
        // const memory = await db.collection('memoryChains').findOne({ memoryId, email });
        
        // if (!memory) {
        //     // Don't reveal if email exists or not
        //     return res.json({ success: true, message: 'If this email is registered, you will receive reset instructions' });
        // }

        // Generate reset token
        const resetToken = generateResetToken();
        const resetTokenExpiry = new Date(Date.now() + 60 * 60 * 1000); // 1 hour

        // Store token
        // await db.collection('memoryChains').updateOne(
        //     { memoryId },
        //     { $set: { resetToken, resetTokenExpiry } }
        // );

        // Send reset email
        const resetUrl = `https://smartlocket.com/reset-password?token=${resetToken}&id=${memoryId}`;

        await transporter.sendMail({
            from: 'SmartLocket <memorychain@yourdomain.com>',
            to: email,
            subject: 'Reset Your SmartLocket Passcode',
            html: `
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <div style="background: linear-gradient(135deg, #000000ff 0%, #ffffffff 100%); padding: 30px; text-align: center; color: white;">
                        <h1>Reset Your Passcode</h1>
                    </div>
                    <div style="padding: 30px;">
                        <h2>Password Reset Request</h2>
                        <p>We received a request to reset the passcode for your SmartLocket:</p>
                        <p><strong>SmartLocket ID:</strong> ${memoryId}</p>
                        
                        <div style="text-align: center; margin: 30px 0;">
                            <a href="${resetUrl}" style="background: #000000ff; color: white; padding: 15px 30px; text-decoration: none; border-radius: 10px; display: inline-block;">Reset Passcode</a>
                        </div>
                        
                        <p style="color: #666; font-size: 14px;">This link will expire in 1 hour.</p>
                        <p style="color: #666; font-size: 14px;">If you didn't request this, please ignore this email. Your passcode will remain unchanged.</p>
                    </div>
                </div>
            `
        });

        res.json({ 
            success: true, 
            message: 'If this email is registered, you will receive reset instructions' 
        });

    } catch (error) {
        console.error('Password reset request error:', error);
        res.status(500).json({ message: 'Failed to process reset request' });
    }
});

app.post('/api/password-reset/confirm', async (req, res) => {
    const { token, memoryId, newPasscode } = req.body;

    try {
        // Verify token
        // const memory = await db.collection('memoryChains').findOne({
        //     memoryId,
        //     resetToken: token,
        //     resetTokenExpiry: { $gt: new Date() }
        // });

        // if (!memory) {
        //     return res.status(400).json({ message: 'Invalid or expired reset token' });
        // }

        // Hash new passcode
        const passcodeHash = await hashPasscode(newPasscode);

        // Update database
        // await db.collection('memoryChains').updateOne(
        //     { memoryId },
        //     {
        //         $set: { passcodeHash },
        //         $unset: { resetToken: '', resetTokenExpiry: '' }
        //     }
        // );

        res.json({ success: true, message: 'Passcode reset successfully' });

    } catch (error) {
        console.error('Password reset confirm error:', error);
        res.status(500).json({ message: 'Failed to reset passcode' });
    }
});

// ==========================================
// MODAL-BASED PASSCODE RESET
// ==========================================

// Request reset with verification code
app.post('/api/memory/request-reset', async (req, res) => {
    const { memoryId, email } = req.body;

    try {
        if (!memoryId || !email) {
            return res.status(400).json({ 
                success: false, 
                message: 'Memory ID and email are required' 
            });
        }

        // Get memory from Firestore
        const memoryRef = db.collection('nfcChains').doc(memoryId);
        const memoryDoc = await memoryRef.get();

        if (!memoryDoc.exists) {
            return res.status(404).json({ 
                success: false, 
                message: 'Memory ID not found' 
            });
        }

        const memoryData = memoryDoc.data();

        // Verify email matches
        if (memoryData.email !== email) {
            return res.status(400).json({ 
                success: false, 
                message: 'Email does not match this Memory ID' 
            });
        }

        // Generate 6-digit verification code
        const verificationCode = generateVerificationCode();
        const resetToken = generateResetToken();
        const codeExpiry = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

        // Store code in Firestore
        await memoryRef.update({
            resetCode: verificationCode,
            resetToken: resetToken,
            resetCodeExpiry: admin.firestore.Timestamp.fromDate(codeExpiry)
        });

        // Send email with verification code
        await transporter.sendMail({
            from: 'SmartLocket <memorychain@yourdomain.com>',
            to: email,
            subject: 'Your SmartLocket Verification Code',
            html: `
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <div style="background: linear-gradient(135deg, #000000ff 0%, #ffffffff 100%); padding: 30px; text-align: center; color: white;">
                        <h1>Reset Your Passcode</h1>
                    </div>
                    <div style="padding: 30px;">
                        <h2>Verification Code</h2>
                        <p>You requested to reset the passcode for your SmartLocket:</p>
                        <p><strong>SmartLocket ID:</strong> ${memoryId}</p>

                        <div style="text-align: center; margin: 30px 0;">
                            <div style="background: #f5f5f5; padding: 20px; border-radius: 10px; display: inline-block;">
                                <p style="margin: 0; color: #666; font-size: 14px;">Your verification code is:</p>
                                <h1 style="margin: 10px 0; color: #000000ff; font-size: 48px; letter-spacing: 8px; font-family: monospace;">${verificationCode}</h1>
                            </div>
                        </div>
                        
                        <p style="color: #666; font-size: 14px;">This code will expire in 10 minutes.</p>
                        <p style="color: #666; font-size: 14px;">If you didn't request this, please ignore this email. Your passcode will remain unchanged.</p>
                    </div>
                </div>
            `
        });

        res.json({ 
            success: true, 
            message: 'Verification code sent to your email',
            token: resetToken
        });

    } catch (error) {
        console.error('Request reset error:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Failed to send verification code. Please try again.' 
        });
    }
});

// Reset passcode with verification code
app.post('/api/memory/reset-passcode', async (req, res) => {
    const { memoryId, code, newPasscode, token } = req.body;

    try {
        if (!memoryId || !code || !newPasscode || !token) {
            return res.status(400).json({ 
                success: false, 
                message: 'All fields are required' 
            });
        }

        // Validate passcode format
        if (!/^\d{6}$/.test(newPasscode)) {
            return res.status(400).json({ 
                success: false, 
                message: 'Passcode must be 6 digits' 
            });
        }

        // Get memory from Firestore
        const memoryRef = db.collection('nfcChains').doc(memoryId);
        const memoryDoc = await memoryRef.get();

        if (!memoryDoc.exists) {
            return res.status(404).json({ 
                success: false, 
                message: 'Memory ID not found' 
            });
        }

        const memoryData = memoryDoc.data();

        // Verify token matches
        if (memoryData.resetToken !== token) {
            return res.status(400).json({ 
                success: false, 
                message: 'Invalid reset session' 
            });
        }

        // Verify code matches
        if (memoryData.resetCode !== code) {
            return res.status(400).json({ 
                success: false, 
                message: 'Invalid verification code' 
            });
        }

        // Check if code expired
        const expiryTime = memoryData.resetCodeExpiry.toDate();
        if (new Date() > expiryTime) {
            return res.status(400).json({ 
                success: false, 
                message: 'Verification code has expired. Please request a new one.' 
            });
        }

        // Hash new passcode
        const passcodeHash = await hashPasscode(newPasscode);

        // Update passcode and clear reset data
        await memoryRef.update({
            passcodeHash: passcodeHash,
            resetCode: admin.firestore.FieldValue.delete(),
            resetToken: admin.firestore.FieldValue.delete(),
            resetCodeExpiry: admin.firestore.FieldValue.delete()
        });

        res.json({ 
            success: true, 
            message: 'Passcode reset successfully',
            passcodeHash: passcodeHash
        });

    } catch (error) {
        console.error('Reset passcode error:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Failed to reset passcode. Please try again.' 
        });
    }
});

// ==========================================
// EDIT MODE API - PASSCODE VERIFICATION
// ==========================================

app.post('/api/memory/:memoryId/verify', async (req, res) => {
    const { memoryId } = req.params;
    const { passcode } = req.body;

    try {
        // const memory = await db.collection('memoryChains').findOne({ memoryId });

        // if (!memory) {
        //     return res.status(404).json({ message: 'MemoryChain not found' });
        // }

        // const isValid = await verifyPasscode(passcode, memory.passcodeHash);

        // if (!isValid) {
        //     return res.status(401).json({ message: 'Invalid passcode' });
        // }

        // Generate session token
        const sessionToken = crypto.randomBytes(32).toString('hex');

        res.json({
            success: true,
            token: sessionToken
        });

    } catch (error) {
        console.error('Verify passcode error:', error);
        res.status(500).json({ message: 'Failed to verify passcode' });
    }
});

// ==========================================
// MEMORY STATUS API
// ==========================================

app.get('/api/memory/:memoryId/status', async (req, res) => {
    const { memoryId } = req.params;

    try {
        const docRef = db.collection('nfcChains').doc(memoryId);
        const doc = await docRef.get();

        if (!doc.exists) {
            return res.status(404).json({ message: 'NFCchain not found' });
        }

        const data = doc.data();

        res.json({
            memoryId,
            activated: data.status === 'activated',
            premium: data.premium,
            photoLimit: data.photoLimit
        });

    } catch (error) {
        console.error('Get status error:', error);
        res.status(500).json({ message: 'Failed to get status' });
    }
});

// ==========================================
// GALLERY DATA API
// ==========================================

// Get full gallery data
app.get('/api/memory/:memoryId', async (req, res) => {
    const { memoryId } = req.params;

    try {
        const docRef = db.collection('nfcChains').doc(memoryId);
        const doc = await docRef.get();

        if (!doc.exists) {
            return res.status(404).json({ message: 'NFCchain not found' });
        }

        const data = doc.data();

        console.log(`üìñ Loading gallery ${memoryId}:`, {
            hasImages: !!data.images,
            imageCount: data.images?.length || 0,
            hasThemeSettings: !!data.themeSettings
        });

        res.json({
            memoryId: data.memoryId,
            status: data.status,
            premium: data.premium,
            photoLimit: data.photoLimit,
            photoCount: data.photoCount,
            galleryTitle: data.galleryTitle,
            galleryData: data.galleryData,
            images: data.images || [],
            letterContent: data.letterContent,
            spotifyUrl: data.spotifyUrl,
            spotifyTrack: data.spotifyTrack || null, // New Spotify track object
            themeSettings: data.themeSettings || null,
            passcodeHash: data.passcodeHash || null, // For passcode verification
            createdAt: formatTimestamp(data.createdAt),
            activatedAt: formatTimestamp(data.activatedAt)
        });

    } catch (error) {
        console.error('Get gallery error:', error);
        res.status(500).json({ message: 'Failed to get gallery data' });
    }
});

// Update gallery data (requires authentication in production)
app.put('/api/memory/:memoryId', async (req, res) => {
    const { memoryId } = req.params;
    const { galleryTitle, galleryData, images, letterContent, spotifyUrl, spotifyTrack, themeSettings } = req.body;

    try {
        console.log(`üìù Updating gallery ${memoryId}:`, {
            hasGalleryTitle: !!galleryTitle,
            hasImages: !!images,
            imageCount: images?.length,
            hasLetterContent: !!letterContent,
            hasSpotifyUrl: !!spotifyUrl,
            hasSpotifyTrack: !!spotifyTrack,
            hasThemeSettings: !!themeSettings
        });

        const docRef = db.collection('nfcChains').doc(memoryId);
        const doc = await docRef.get();

        if (!doc.exists) {
            return res.status(404).json({ message: 'NFCchain not found' });
        }

        // Update only provided fields
        const updates = {};
        if (galleryTitle !== undefined) updates.galleryTitle = galleryTitle;
        if (galleryData !== undefined) updates.galleryData = galleryData;
        if (images !== undefined) {
            // Store images with URLs from Storage or base64 + favorite flag for premium
            updates.images = images.map(img => ({
                id: img.id || 0,
                title: String(img.title || ''),
                description: String(img.description || ''),
                fullImage: String(img.fullImage || ''),
                thumbnail: String(img.thumbnail || img.fullImage || ''),
                fileName: String(img.fileName || ''), // For Storage deletion
                date: String(img.date || ''),
                location: String(img.location || ''),
                tags: String(img.tags || ''),
                isFavorite: Boolean(img.isFavorite || false) // Premium feature
            }));
            updates.photoCount = images.length;
        }
        if (letterContent !== undefined) {
            // Sanitize letterContent to ensure Firebase compatibility
            updates.letterContent = {
                title: String(letterContent.title || 'Welcome'),
                paragraphs: Array.isArray(letterContent.paragraphs) 
                    ? letterContent.paragraphs.map(p => String(p || ''))
                    : []
            };
        }
        
        // Support both spotifyUrl (legacy) and spotifyTrack (new format)
        if (spotifyUrl !== undefined) {
            updates.spotifyUrl = spotifyUrl === null ? null : String(spotifyUrl);
        }
        if (spotifyTrack !== undefined) {
            if (spotifyTrack === null) {
                updates.spotifyTrack = null;
            } else {
                updates.spotifyTrack = {
                    type: String(spotifyTrack.type || 'track'),
                    id: String(spotifyTrack.id || ''),
                    embedUrl: String(spotifyTrack.embedUrl || '')
                };
            }
        }
        
        if (themeSettings !== undefined) {
            updates.themeSettings = {
                theme: String(themeSettings.theme || 'light'),
                backgroundStyle: String(themeSettings.backgroundStyle || 'solid'),
                colorTheme: String(themeSettings.colorTheme || 'blue'),
                showWelcomeLetter: Boolean(themeSettings.showWelcomeLetter)
            };
        }
        
        updates.updatedAt = admin.firestore.FieldValue.serverTimestamp();

        await docRef.update(updates);

        console.log(`‚úÖ Gallery ${memoryId} updated successfully`);

        res.json({
            success: true,
            message: 'Gallery updated successfully',
            memoryId
        });

    } catch (error) {
        console.error('Update gallery error:', error);
        console.error('Error details:', error.message, error.stack);
        res.status(500).json({ 
            message: 'Failed to update gallery',
            error: error.message 
        });
    }
});

// Verify passcode for edit mode access
app.post('/api/verify-passcode', async (req, res) => {
    const { memoryId, passcode } = req.body;

    if (!memoryId || !passcode) {
        return res.status(400).json({ 
            valid: false, 
            message: 'Memory ID and passcode are required' 
        });
    }

    try {
        const docRef = db.collection('nfcChains').doc(memoryId);
        const doc = await docRef.get();

        if (!doc.exists) {
            return res.status(404).json({ 
                valid: false, 
                message: 'SmartLocket not found' 
            });
        }

        const data = doc.data();

        if (!data.passcodeHash) {
            // No passcode set - allow access
            console.log(`‚ö†Ô∏è No passcode set for ${memoryId}`);
            return res.json({ valid: true });
        }

        // Verify passcode
        const isValid = await verifyPasscode(passcode, data.passcodeHash);

        console.log(`üîí Passcode verification for ${memoryId}: ${isValid ? '‚úÖ Valid' : '‚ùå Invalid'}`);

        res.json({ valid: isValid });

    } catch (error) {
        console.error('Passcode verification error:', error);
        res.status(500).json({ 
            valid: false, 
            message: 'Verification failed' 
        });
    }
});

// ==========================================
// FIREBASE STORAGE - IMAGE UPLOAD/DELETE
// ==========================================

// Upload image to Firebase Storage
app.post('/api/upload-image', async (req, res) => {
    const { memoryId, imageData, fileName } = req.body;

    if (!memoryId || !imageData) {
        return res.status(400).json({ message: 'Memory ID and image data required' });
    }

    try {
        console.log(`üì§ Uploading image to R2 for ${memoryId}...`);

        // Convert base64 to buffer
        const base64Data = imageData.replace(/^data:image\/\w+;base64,/, '');
        const buffer = Buffer.from(base64Data, 'base64');
        console.log(`üìä Image size: ${(buffer.length / 1024).toFixed(2)}KB`);

        // Generate unique filename
        const timestamp = Date.now();
        const randomStr = Math.random().toString(36).substring(7);
        const fileExtension = fileName ? fileName.split('.').pop() : 'jpg';
        const uniqueFileName = `${memoryId}/${timestamp}_${randomStr}.${fileExtension}`;

        // Determine content type
        const contentType = imageData.match(/data:([^;]+)/)?.[1] || 'image/jpeg';

        // Upload to Cloudflare R2 using AWS SDK
        const uploadParams = {
            Bucket: process.env.R2_BUCKET_NAME,
            Key: uniqueFileName,
            Body: buffer,
            ContentType: contentType,
            CacheControl: 'public, max-age=31536000', // Cache for 1 year
            Metadata: {
                memoryId: memoryId,
                uploadedAt: new Date().toISOString()
            }
        };

        await r2Client.send(new PutObjectCommand(uploadParams));

        // Generate public URL
        const publicUrl = `${process.env.R2_PUBLIC_URL}/${uniqueFileName}`;

        console.log(`‚úÖ Image uploaded to R2: ${publicUrl}`);

        res.json({
            success: true,
            url: publicUrl,
            fileName: uniqueFileName,
            storage: 'r2' // Indicate it's stored in R2
        });

    } catch (error) {
        console.error('‚ùå R2 upload error:', error);
        res.status(500).json({ 
            message: 'Failed to upload image to R2',
            error: error.message
        });
    }
});

// Delete image from Firebase Storage
app.delete('/api/delete-image', async (req, res) => {
    const { fileName } = req.body;

    if (!fileName) {
        return res.status(400).json({ message: 'File name required' });
    }

    try {
        console.log(`üóëÔ∏è Deleting image from R2: ${fileName}`);

        // Delete from Cloudflare R2
        await r2Client.send(new DeleteObjectCommand({
            Bucket: process.env.R2_BUCKET_NAME,
            Key: fileName
        }));

        console.log(`‚úÖ Image deleted from R2: ${fileName}`);

        res.json({
            success: true,
            message: 'Image deleted successfully from R2'
        });

    } catch (error) {
        console.error('‚ùå R2 delete error:', error);
        res.status(500).json({ 
            message: 'Failed to delete image from R2',
            error: error.message 
        });
    }
});

// Serve HTML files for direct navigation (e.g., /activate.html)
app.get(['/*.html', '/'], (req, res, next) => {
    const file = req.path === '/' ? 'index.html' : req.path.replace(/^\//, '');
    res.sendFile(path.join(__dirname, '../public', file), err => {
        if (err) next();
    });
});

const PORT = process.env.PORT || 3000;
// The following block is ONLY for local/server development. It must be disabled for Firebase Functions deployment.
// Commented out to prevent EADDRINUSE error in Firebase Functions:
// app.listen(PORT, () => {
//     console.log(`‚úÖ Server running on port ${PORT}`);
//     console.log(`üî• Firebase connected`);
//     console.log(`üìä Collection: nfcChains`);
//     console.log(`üóÑÔ∏è Storage bucket: ${bucket.name}`);
// });

module.exports = app;
